#include "model.h"
#include <cstdlib>
#include <ctime>

using namespace std;

// Constructor initializes the object
Model::Model() {
	//initialize location variables for road and car
	source_road_1.x = 0;
	source_road_1.y = 0;
	source_road_1.w = 1280;
	source_road_1.h = 720;
	destination_road_1.y = 0;
	destination_road_1.x = 0;
	
	source_road_2.x = 0;
	source_road_2.y = 720;
	source_road_2.w = 1280;
	source_road_2.h = 0;
	destination_road_2.y = 0;
	destination_road_2.x = 0;
	
	destination_car.y = 530;
	destination_car.x = 490;
	
<<<<<<< HEAD
	p = 2;
	
	//at start of game, game is NOT over
	game_over = false;
=======
	source_obstacle.x = 0;
	source_obstacle.y = 101;
	source_obstacle.w = 80;
	source_obstacle.h = 1;
	destination_obstacle.y = 0;
	destination_obstacle.x = 490;
	
	scoreCounter.x = 7;
	scoreCounter.y = 3;
	
	scoreCounterShadow.x = 9;
	scoreCounterShadow.y = 5;
	
	MESSAGE.x = 233;
	MESSAGE.y = 330;
	
	MESSAGE_SHADOW.x = 235;
	MESSAGE_SHADOW.y = 332;
>>>>>>> 9a519f25b05ac96af3ccd85186ec439fc5319feb
}
// Destructor deletes dynamically allocated memory
Model::~Model() {
	
}

bool Model::gameOver() {
<<<<<<< HEAD
	//collision detection  						Doesnt work half the time when hitting obstacle from the right side. FIX***********
	for (std::list<Debris>::iterator it = obstacles.begin(); it != obstacles.end(); it++) {
		game_over = (((it->dest.y + it->source.h) >= 530) && !(destination_car.x + 121 < it->dest.x || destination_car.x > it->dest.x + it->source.w));
	}
	return game_over;
=======
	//collision detection
       // return (((destination_obstacle.y + destination_obstacle.h) >= 530 && (destination_obstacle.y + destination_obstacle.h) <= 720) &&
		//	!(destination_car.x + 121 < destination_obstacle.x || destination_car.x > destination_obstacle.x + destination_obstacle.w));
			
			return false;
}

bool Model::collided() {
	//collision detection
    return (((destination_obstacle.y + destination_obstacle.h) >= 530 && (destination_obstacle.y + destination_obstacle.h) <= 720) &&
			!(destination_car.x + 121 < destination_obstacle.x || destination_car.x > destination_obstacle.x + destination_obstacle.w));
>>>>>>> 9a519f25b05ac96af3ccd85186ec439fc5319feb
}

void Model::go(Direction d)
{
	direction = d;
	return;
}

void Model::calculate(Model * model)
{
	currentTime = SDL_GetTicks();
	if(currentTime - lastTime > 1000)
	{
		score += 100*MULTIPLIER;
		lastTime = currentTime;
	}
	
/* Speed phases - for later
	if(currentTime > 5000 && source_road_2.y == 720)
	{
		MULTIPLIER = 2;
		OFFSET = 30;
	}
	
	if(currentTime > 10000 && source_road_2.y == 720)
	{
		MULTIPLIER = 3;
		OFFSET = 40;
	}
*/
		
	//update bottom part of road image
<<<<<<< HEAD
	source_road_1.h = source_road_1.h - p;
    destination_road_1.y = destination_road_1.y + p;
=======
	source_road_1.h -= 1*MULTIPLIER;// = source_road_1.h - 1;
	destination_road_1.y += 1*MULTIPLIER;// = destination_road_1.y + 1;
>>>>>>> 9a519f25b05ac96af3ccd85186ec439fc5319feb
	

	//update top part of road image
<<<<<<< HEAD
    source_road_2.y = source_road_2.y - p;
    source_road_2.h = source_road_2.h + p; 
	
=======
    source_road_2.y -= 1 * MULTIPLIER;// = source_road_2.y - 1;
    source_road_2.h += 1*MULTIPLIER;// = source_road_2.h + 1;


>>>>>>> 9a519f25b05ac96af3ccd85186ec439fc5319feb
	//reset road image after every loop through
	if (source_road_2.y == 0 || source_road_2.h == 720) {
		source_road_1.h = 720;
		destination_road_1.y = 0;
		source_road_2.y = 720;
		source_road_2.h = 0;
	}
	
	//updates car position
	switch(direction)
	{
<<<<<<< HEAD
		case LEFT: destination_car.x = destination_car.x - 2;
		break;
		case RIGHT: destination_car.x = destination_car.x + 2;
=======
		case LEFT: destination_car.x = destination_car.x - OFFSET;
		break;
		case RIGHT: destination_car.x = destination_car.x + OFFSET;
>>>>>>> 9a519f25b05ac96af3ccd85186ec439fc5319feb
		break;
		case STAGNANT:
		break;
	}
	
<<<<<<< HEAD
	//update obstacle positions
	for (std::list<Debris>::iterator it = obstacles.begin(); it != obstacles.end(); it++) {
		it->dest.y = it->dest.y + p;	
			if (it->source.y > 0) {
				it->source.y = it->source.y - p;
				it->source.h = it->source.h + p;
				it->dest.y = it->dest.y - p;
		}
		//check if image is off screen. if so, pop that ish outa hurr
		if (it->dest.y > 720) {
			//just do pop_front instead of getting rid of the specific debris because the only obstacle which will be this far down at any 
			//given time is the first element (oldest one)
			obstacles.pop_front();
		}
=======
	if(destination_car.x < 200)
		destination_car.x += 100;
	
	if(destination_car.x > 1000)
		destination_car.x -= 100;
	
	//update obstacle position
	destination_obstacle.y++;
	if (source_obstacle.y > 0) {
		source_obstacle.y--;
		source_obstacle.h++;
		destination_obstacle.y--;
>>>>>>> 9a519f25b05ac96af3ccd85186ec439fc5319feb
	}
	return;
}

Debris::Debris() {
	source.x = 0;
	source.y = 120;
	source.w = 100;
	source.h = 1;
	dest.y = 0;
	//dest.x is set randomly in controller
}

